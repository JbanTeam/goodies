// github pages
// Сделать отдельный репозиторий для каждого сайта (это иногда удобнее, чем поддиректории) и в каждом таком репозитории создать ветку gh-pages. Соответственно содержимое будет автоматически расположено по адресу nickname.github.io/repo_name/

// но в любом случае домен каждого сайта будет nickname.github.io/site/

// Подготовка***************************************************
// git init - инициализируем корневой каталог гит
// git config user.name "Vital Jban" - устанавливаем имя пользователя
// git config user.name JbanTeam@yandex.ru - устанавливает email
// git config --global user.name "Vital Jban" - устанавливает имя пользователя глобально
// git config --global user.email JbanTeam@yandex.ru - устанавливает email глобально
// cat .git/config - посмотреть текущие настройки
// git config --list - выводит лист конфигурации
// git config --list --global (cat ~/.gitconfig)- выводит лист глобальной конфигурации
// git config --unset user.name; git config --unset --global uset.name - удалить настройку
// git config --remove-section user - удалить всю секцию

// git config --global alias.c 'config --global'- команду git config --global теперь можно вызывать git c
// git config alias.sayHi '!git ...; git ...' - несколько команд

// git config --global core.editor "'c:\program files\sublime text 3\subl.exe' -w" - чтобы команды гит вызывали sublime
// git config --global core.editor "subl -n -w" - для линукса

// разобраться с .gitattributes, .gitignore***********************************************************
// git config --global core.excludesFile ~/.gitignore - создать глобальный .gitignore
// code ~/.gitignore - запустить его в VS Code

// Создание репозитория, первый коммит****************************************************************
// git status - показывает отслеживаемые файлы
// git add index.html - добавить файл во временное хранилище(индекс)
// git add . - помещает все измененные файлы
// git commit - отправить файлы в репозиторий
// git commit src/script.js - отправить конкретный файл в репозиторий
// git commit -m 'Added src' - отправить в репозиторий без вызова редактора (sublime)
// git commit --author='Jban Jban <jban@mail.ru>' --date='...' - коммитит и устанавливает автора и дату
// git commit -a - отправить в репозиторий минуя стадию индексации (git add), только для уже проиндексированных
// git commit -v - покажет какие изменения будут закоммичены
// git show (--pretty=fuller) - показать информацию о коммите (более полная)
// git config --global alias.commitall '!git add .;git commit' - индексирует и коммитит все изменения в текущей директории (git commitall)
// git config --global alias.commitall '!git add -A;git commit' - индексирует и коммитит все изменения во всем проекте

// git rm file - удаляет файл
// rm -rf .git - удалить репозиторий
// git rm -r src - удаляет директорию
// git rm -r --cached src - удаляет директорию из индекса, но оставляет в рабочем каталоге
// git rm -f index.html - удаляет неиндексируемый файл из рабочего каталога (теряются сохранения)
// git mv index.html hello.html - переименовывает файл и добавляет в индекс

// Ветки**************************************************************************************************
// git branch - показывает существующие ветки (master, ...)
// git branch -v - показывает существующие ветки и ссылки на коммит(master, ...)
// git branch newmaster - создаем новую ветку
// git branch -d newmaster - удаляем ветку, если ветки смерджены(находятся на одном коммите(объединена в текущей), например master/newmaster)
// git branch -D newmaster - удаляем ветку, коммиты становятся недостижимыми и со временем удалятся, но в данный момент еще можно все вернуть назад(git branch newmaster (коммит на который newmaster указывал до удаления))
// git checkout newmaster - переключаемся на новую ветку
// git checkout -b fix - создать новую ветку fix и сразу переключиться на нее
// git checkout -f master - принудительно переключиться на ветку мастер, если в текущей ветке есть не закоммиченные изменения, не сохранятся
// git checkout -f - переключиться на текущую ветку (перезапишет файлы в последнее закоммиченное состояние)
// git stash - позволяет сохранить незаконченные изменения и потом к ним вернуться командой git stash pop(лучше на той же ветке)

// Если внесенные коммиты нужно было сделать в новой ветке
// Создаем новую ветку в текущем месте git branch vetka
// Переключаемся на созданную ветку git checkout vetka
// git branch -f master 54a4 - откатываем ветку мастер на нужный коммит (54a4 - коммит)
// git branch -f master fix - откатываем ветку мастер обратно
// git checkout -B master 54a4 - откатываем ветку мастер на нужный коммит и переключаемся на нее
// git checkout -B master fix - создаем ветку мастер(если ее еще нет), пепедвигаем на нужную позицию(fix)

// git checkout 54a5 index.html - загрузить версию файла из указанного коммита, если в данный момент закоммитить то последним коммитом станет версия из 54a4
// git reset index.html - сбросить индексацию 
// Если не понравились внесенные изменения
// git checkout HEAD index.html - возвращаем версию файла из последнего коммита
// git checkout index.html - возвращаем версию файла из индекса
// git checkout -- master - переключаемся на путь мастер, а не на ветку

// git log - выводит все коммиты
// git log --oneline - выводит все коммиты в компактном виде
// git log master --oneline - коммиты определенной ветки
// git show HEAD~ - показать предыдущий коммит от текущего (~~ на 2 коммита назад и тп.; @ - сокращ. HEAD)
// git show @~ = git show HEAD~
// git show fix:index.htnl - посмотреть версию файла из ветки fix
// git show @~:index.htnl - посмотреть версию файла из предыдущего коммита
// git show :index.htnl - посмотреть версию файла текущую проиндексированную
// git show :/sayBye - показывает коммит с указанным словом в описании (sayBye)

// git checkout master - переключаемся на мастер
// git merge fix - слияние веток, теперь мастер такая же как и fix
// git branch -f master ORIG_HEAD - откатить мастер на коммит до слияния

// git branch -d fix - удаляет ветку fix, если она объединена еще с какой то веткой
// git branch -D fix - удаляет ветку fix даже если не объединена(коммиты этой ветки остаются в базе какое то время, потом удаляются)
// git branch feature 2c11 - ветку можно вернуть если создать новую ветку ссылающуюся на последний коммит удаленной ветки
// git reflog - логирование ветки HEAD(коммиты, checkout)
// git branch feature HEAD@{6} - создать ветку из шестой записи лога HEAD
// git reflog --date=iso - вывод лога с датами
// git branch feature HEAD@{'2017-09-12 22:40:07 +0200'} - создать ветку из коммита соответствующей даты записи лога HEAD
// Записи в reflog хранятся 90 дней, недостижимые коммиты 30 дней
// git checkout @{-1} - переключиться на ветку с которой последний раз был произведен checkout

// git gc - чистит недостижимые коммиты старше 2х недель
// git reflog expire --expire=now --all - чистит все reflog
// git gc --prune=now - чистит недостижимые коммиты старше чем сейчас (тоесть все)

// Теги*************************************************************************************************
// git tag v1.0.0 21ac - устанавливает тег v1.0.0 на коммит
// тег не перемещается в отличии от ветки, часто используют для маркировки релизов
// git tag - выводит список тегов
// git tag --contains 54a4 - какие релизы содержат указанный коммит
// git tag -n - выводит список тегов с сообщениями
// git tag -n -l 'v1.1*' - выводит список тегов с сообщениями соответствующие маске
// git tag -d v1.0.0 v1.1.0 - удаляет теги
// git tag -a -m 'Version 1.0.0' v.1.0.0 master - тег с аннотацией на коммит куда указывает ветка мастер
// git describe 1913 - показывает тег по коммиту
// git describe - показывает название ближайшего тега и на сколько коммитов мы впереди (v1.0.0-2-g2c11f12) и сокращ запись коммита
// git archive -o /tmp/v1.0.0-2-g2c11f12.zip HEAD - создает архив из содержимого репозитория на момент нужного коммита (-o указывает директорию куда положить архив)

// Reset - отмена коммита***************************************************************************
// git reset --hard 2fad - откат на указанный коммит, текущий коммит станет недостижимым и потом удалится
// git reset --hard ORIG_HEAD - откат обратно, это возможно пока коммит еще остается в базе
// --hard используется для полного удаления изменений и незакоммиченных(индексированных)
// git reset --soft @~ - мягкий ресет на 1 коммит назад, отменяет коммит, файлы в рабочей директории и в индексе остаются такие же, а сам коммит отменяется, часто используется для исправления ошибок в коммите
// git reset --soft ORIG_HEAD - откатиться обратно
// git reset --keep @~ - производит откат на 1 коммит назад, но не трогает изменения в рабочей директории(для тех файлов, для которых возможно)
// git reset --merge - проиндексированные изменения удаляются, непроиндексированные остаются
// git commit -C ORIG_HEAD - коммитим исправленный с названием из старого коммита 
// git commit -C ORIG_HEAD --reset-author - коммитим исправленный с названием из старого коммита(возьмет только сообщение, информацию об авторе и дате коммита автора не скопирует)
// git reset mixed @~ или git reset @~ - ресет на 1 коммит назад, отменяет коммит, файлы в рабочей директории остаются, в индексе и сам коммит отменяются
// git reset - сбросить индексацию
// git reset index.html - сбросить индексацию конкретного файла
// git commit --amend - заменяет коммит на обновленный(2 в одном, git reset --soft @~ и git commit -C ORIG_HEAD)
// git commit --amend --reset-author --no-edit - не копирует информацию об авторе и не вызывает редактор

// git clean -dxf - удаляет неотслеживаемые файлы (-d - еще и директории; -x - еще и файлы и директории из gitignore; -f - без этого не работает)

// Просмотр, сравнение коммитов***********************************************************************************************
// git diff master feature - сравнение двух коммитов
// git diff master...feature - показывает что именно изменилось
// git diff HEAD - показывает изменения в рабочей директории с момента последнего коммита
// git diff - показывает изменения в рабочей директории по сравнению с индексом
// git diff index.html - показывает изменения в рабочей директории по сравнению с индексом конкретного файла
// git diff -- index.html - более безопасно для путей файлов
// git diff master feature index.html script.js - сравнение двух файлов в указанных коммитах
// git diff --cached - показывает изменения индекса по сравнению с последним коммитом
// git diff --name-only master feature - показывает только имена файлов в которых есть отличия
// git diff commit1:pathtofile commit2:pathtofile - сравнение двух файлов
// git diff --no-index path1 path2 - сравнивает любые 2 файла на диске
// git diff --word-diff - показывает конкретные изменения в словах
// git diff --color-words - показывает конкретные изменения в словах(аналог --word-diff)
// желательно добавить в .gitattributes *.html diff=html  *.css diff=css- чтобы гит правильно отличал строки в html файлах и css

// git log --pretty - задает как выводить лог
// git log --pretty=oneline - компактный вывод по одной строке
// git log --pretty=oneline --abbrev-commit - компактный вывод по одной строке, с сокращенным идентификатором
// git log --oneline - комбинация двух команд выше
// git log --pretty=format:'%h %cd | %s%d [%an]' - формат вывода(%h - сокращ. идентиф. коммита; %cd - дата; %s - заголовок коммита; %d - декорирование, какие ссылки на него указывают; [%an] - имя автора; %cr - относительная дата, сколько времени назад)
// git log --pretty=format:'%h %cd | %s%d [%an]' --date-short - с короткой датой
// git log --pretty=format:'%h %cd | %s%d [%an]' --date=format:'%F %R' - короткая дата и время
// git log --pretty=format:'%C(yellow)%h %C(dim green)%cd %C(reset)| %C(cyan)%s%d %C(#667788)[%an]' --date=format:'%F %R' - %C(yellow) цвет вывода, %C(reset) сброс цвета, %C(#667788) в формате rgb
// git cinfig --global pretty.my format:'%C(#f3f89d)%h %C(#418d61)%cd %C(reset)|%C(F78972)%d %C(#9aedf1)%s' - сохранить формат вывода в конфиге
// git log --pretty=my - вывод согласно сохраненному формату
// git config --global format.pretty my - сохранить вывод как стандартный (git log выведет согласно ему)
// git config --global log.date format-local:'%F %R' - сохранить вывод даты как стандартный(format-local переводит в текущую локаль)
// git log --pretty=medium - вывод в изначальном формате
// git log --patch или -p - добавляет к выводу информацию о внесенных изменениях (git diff)

// git log master - выводит коммиты достижимые из мастер
// git log master feature - выводит коммиты достижимые из мастер и feature
// git log master feature --graph - выводит коммиты достижимые из мастер и feature с разделением
// git log --all --graph - выводит все коммиты
// git log feature ^master - выводит коммиты ветки feature с момента когда она отошла от ветки master
// git log master..feature - выводит коммиты ветки feature с момента когда она отошла от ветки master
// git log feature..(HEAD) --boundary - включает пограничный коммит, HEAD указан явно, без него тоже самое
// git log master...feature - показывает коммиты которые достижимы только в master и feature, но не в них обеих
// git log index.html - коммиты в которых менялся указанный файл
// git log -p script.js - покажет конкретные изменения
// git log -p --follow script.js - покажет конкретные изменения и изменения если файл ранее переименовывался
// git log feature..master index.html - выводит коммиты ветки feature с момента когда она отошла от ветки master, в которых менялся index.html

// git log --grep Run - ищет коммиты в описании которых есть слово Run в ветке HEAD
// git log --grep Run --grep sayHi feature - ищет коммиты в описании которых есть слова Run или sayHi в ветке feature
// git log --grep Run --grep sayHi --all-match feature - ищет коммиты в описании которых есть слова Run и sayHi одновременно в ветке feature
// git config --global grep.patternType perl - задает поиск с помощью регулярных выражений в формате языка perl по умолчанию
// git log -F - задает поиск изначальный по тексту (поисковая строка воспринимается как текст)
// git log --grep sayhi - поиск регистрозависим, sayHi не найдет
// git log --grep sayhi -i - флаг -i задает поиск независимый от регистра
// git log -G sayHi - выводит все коммиты с sayHi независимо от ветки
// git log -G 'function sayHi\(' -p - выводит все коммиты где менялось такое выражение независимо от ветки, показывает эти изменения (-p)
// git log -L 3,6:index.html - осуществляет поиск в файле между строками 3 и 6
// git log -L '/<head>/','/<\/head>/':index.html - поиск между переданными выражениями (внутри тега head)
// git log --author=Jban - поиск по автору
// git log --committer=Jban - поиск по коммиттеру
// git log --before '3 months ago' - поиск по дате до указанной даты
// git log --before '2017-09-13' - поиск по дате до указанной даты
// git log --after '2017-09-13' - поиск по дате после указанной даты

// Слияние************************************************************************************************
// желательно чтобы git status был чист
// git merge-base master feature - показывает базовый коммит от которого в дальнейшем отходят ветки
// git merge feature - слияние текущей ветки с веткой feature
// гит сравнивает 3 версии файлов - базовую, версию текущего коммита(master) и версию feature
// если от базовой версии отличается только одна из версий файлов то в конечном итоге берется она
// если от базовой версии отличаются обе версии, но отличия в разных частях файлов то эти отличия вставляются в базовую версию и конфликта не происходит
// если отличия в совпадающих частях файлов то происходит конфликт, гит выводит оба варианта в конечном файле
// git checkout --ours index.html - применить изменения из версии файла текущей ветки (master)
// git checkout --theirs index.html - применить изменения из версии файла другой ветки (feature)
// git checkout --merge index.html - версия с конфликтом
// git checkout --conflict=diff3 --merge index.html - выводит оба конфликтных варианта и версию из базового файла
// git config --global merge.conflictStyle diff3 - по умолчанию будет выводить оба конфликтных варианта и версию из базового файла
// git reset --hard - прекратить слияние
// git reset --merge - прекращает слияние, не затрагивает изменения которые есть только в рабочей директории

// в итоге получается коммит слияния, у него 2 родителя
// git show - показывает инфу какие коммиты слились, какие изменения из какого коммита
// git show --first-parent - какие изменения из текущей ветки(master) внесены в коммит слияния
// git diff HEAD^ - показывает первого родителя на текущей ветке(master)
// git diff HEAD^^ - показывает первого родителя первого родителя на текущей ветке(master)
// git diff HEAD^2 - показывает второго родителя на ветке feature
// git diff HEAD^2^ - показывает первого родителя второго родителя на ветке feature
// git branch --merged - показывает ветки объединенные с текущей
// git branch --no-merged - показывает ветки не объединенные с текущей
// git merge feature --log - также записывает сообщения заголовков предыдущих коммитов, по умолчанию не более 20
// git log master --oneline - лог всех коммитов достижимых из мастер, в том числе и из ветки feature, так как они сливались
// git log master --oneline --first-parent - лог всех коммитов ветки мастер, без ветки feature

// git reset --hard @~ - откат слияния, коммит слияния становится недостижим
// git merge feature --log - производим слияние, получаем конфликт, в описание попадут описания из предыдущих коммитов
// правим файл как нам нужно
// git add index.html - добавляем в индекс
// git merge --continue - завершаем слияние

// при семантических конфликтах нужно откатить слияние назад
// git merge work --no-commit - произвести слияние, но не коммитить
// исправляем файл как нам нужно
// git add index.html - добавляем в индекс
// git merge --continue - завершаем слияние

// git merge --no-ff --no-edit feature - флаг --no-ff заставляет merge вместо перемотки делать коммит слияния

// git merge --squash 3rdBranch - берет изменения из ветки 3rdBranch и добавляет их в рабочую директорию и индекс
// git commit -m 'Run sayHi and sayBye' - коммитит эти изменения в текущую ветку (master)

// Копирование коммитов**********************************************************************************
// git cherry-pick 2702 - копируем коммит на текущую ветку (master)
// git cherry-pick -x 2702 - копируем коммит на текущую ветку (master), -x добавляет информацию откуда был скопирован коммит
// git cherry-pick master..feature, 2701 340b... - копирует несколько коммитов
// могут также происходить конфликты
// git cherry-pick --abort - полностью отменяет копирование
// git cherry-pick --continue - продолжает копирование (при конфликте невозможно)
// git cherry-pick --quit - остановиться там, где мы сейчас и сбросить запомненное состояние
// правим конфликт в файле
// git add index.html - индексируем
// git cherry-pick --continue - продолжаем копирование
// git cherry-pick -n(--no-commit) 2702 - добавляет в рабочую директорию и индекс, но не коммитит
// git cherry-pick master feature - показывает эквивалентные коммиты
// git log --oneline --cherry-mark --left-right feature...master - более наглядно показывает эквивалентные коммиты, и какой коммит откуда взялся
// git log --oneline --cherry-mark --left-only feature...master - покажет только коммиты из левой ветки
// git log --oneline --cherry-mark --right-only feature...master - покажет только коммиты из левой ветки

// Перемещение коммитов****************************************************************************************
// git rebase master - (находимся на ветке feature) копирует коммиты ветки feature на конечный коммит ветки master(старые коммиты ветки feature становятся недостижимы)
// при конфликтах git rebase --abort - вернет все как и было
// git rebase --quit - остаемся в текущем состоянии, в частично выполненном перебазировании
// git rebase --skip - оставить конфликтный коммит без изменений и продолжить перебазирование
// разрешаем конфликт в файле
// git add index.html - индексируем
// git rebase --continue - завершаем перебазирование
// git reset --hard ORIG_HEAD - откатиться обратно, если в процессе перебазирования не вызывался reset иначе ORIG_HEAD будет другой
// если что, можно посмотреть через log или reflog
// git rebase -x 'node feature.mjs' master - (-x '...') - команда которая будет выполнена при каждом перебазировании коммита, применяется для проверки работоспособности проекта, для тестирования
// git rebase --onto master feature - указывает с какого момента нужно перенести ветку (находимся на ветке fix, которая отходит от ветки feature), переносим на ветку master, с момента отделения от ветки feature
// если в перебазирунмых коммитах будет коммит слияния, rebase его пропустит
// git rebase -i master - интерактивное перебазирование, с вызовом редактора и ручным редактированием
// git rebase --edit-todo - если в процессе перебазирования понадобится, открывает редактор с оставшимися запланированными перебазированиями
// rebase можно использовать для редактирования коммитов(названия...) командой git rebase -i @~(количество коммитов назад)

// если нужно внести исправления в какой нибудь коммит
// git commit -a --fixup=371b(id) - создаем заплатку для коммита, можно использовать флаг --squash
// git rebase -i --autosquash - вызовет редактор, найдет коммит 371b и поставит заплатку сразу после него, в перебазированной ветке эти 2 коммита сольются в один

// ReReRe - авторазрешение повторных конфликтов, при отменен rebase, merge**********************************************
// git config rerere.enabled true - включает rerere по умолчанию
// git merge master - получаем конфликт
// исправляем конфликт
// git add index.html - индексируем
// git commit --no-edit - коммитим
// rerere запоминает как был разрешен этот конфликт
// если далее мы куда то откатываемся, вносим изменения, а потом коммитим по-новой, то если в файле index.html будет конфликт по тому же самому поводу - он разрешится автоматически

// если нам нужно по другому разрешить конфликт
// git checkout --merge index.html - откатываемся на конфликтную версию файла
// git rerere forget index.html - забываем как был разрешен конфликт
// исправляем конфликт как нам нужно
// git commit -a --no-edit - коммитим

// Обращение коммитов*******************************************************************************************
// git revert @ - создает коммит обратный указанному(текущему), тоесть если в указанный были внесены какие-то изменения, то revert делает коммит без них(можно использовать отмену отмены, применить revert на коммите, на котором revert уже был)
// git revert commit1..commit2 - можно задать диапазон коммитов
// revert коммита слияния
// git revert 38e8 -m 1 - указываем по отношению к какому родителю нужно отменить изменения
// чтобы слить коммиты по-новой
// делаем отмену отмены git revert 38e8
// git merge feature --no-edit - сливаем поновой
// лучше избегать отмены слияний

// эту задачу можно решить с помощью rebase
// копируем коммиты ветки feature чтобы они отходили от вершины ветки мастер
// git rebase --onto master 54a4 - находимся на ветке feature, копируем коммиты ветки feature от коммита разъединения от ветки master
// git merge --no-ff - производим слияние поновой (не перемоткой)

// и еще один способ
// git rebase 54a4 --no-ff - скопирует все коммиты ветки (feature) отходящие от того же места что и предыдущая версия этой ветки, но промежуточных слияний этой ветки с веткой master уже не будет

// Даты в git*********************************************************************************************
// git log --pretty='%ci | %s' --before='2018-01-02' - выведет коммиты до текущего времени, если оно не указано явно, то подазумевается настоящее время
// 2018-01-30 -указанная дата в настоящее время
// 15:30 - настоящая дата в указанное время
// 4pm - настоящая дата в указанное время
// 3 weeks = 3 weeks ago = 3.weeks.ago - 3 недели назад от текущего времени
// 1 year 2 month 5 vinutes 1 second
// one year twoo weeks
// yesterday - вчера в то же время
// midnight - настоящая дата в полночь
// noon - настоящая дата в полдень
// never - 1970-01-01 00:00
// now - настоящая дата в настоящее время

// форматирование для вывода дат
// git log --pretty='%cd | %s' --date=...
// default - формат по умолчанию Tue Jan 30 12:30:00 2018 +0300
// rfc - Tue, 30 Jan 2018 12:30:00 +0300
// iso - 2018-01-30 12:30:00 +0300
// iso-strict - 2018-01-30T12:30:00+03:00
// short - 2018-01-30
// unix - 1517304600 (количество милисекунд)
// raw - 1517304600 +0300
// relative - 2 month ago
// format - '%F %T', see strftime(спец. функция)

// git log --pretty='%cd | %s' --date=format:'%F %T %z' - формат идентичный iso

// git log --pretty='%cd | %s' --date=iso-local - переводит дату в текущую локаль (нельзя использовать с unix и raw)

// Удаленный репозиторий*************************************************************************************************
// git clone url - создать репозиторий на основе удаленного
// git push - отправляет закоммиченные изменения
// git pull - получает изменения и накладывает их на текущую ветку в локальном репо
// git fetch - просто получить изменения
// git remote add origin https://github.com/JbanTeam/Test.git - синхронизирует локальный и удаленный репозитории
// git remote show origin - информация о репо
// git push -u origin master - отправить изменения на удаленный репозиторий
// git push origin newbranch - залить новую ветку на удаленный репо (нужно находиться на ней в локальном репо)
// git pull origin testbranch - получает изменения с указанной ветки
// git pull --rebase origin testbranch - получает удаленные изменения накладывает их на локальный репо и только потом накладывает локальные изменения ()



// **************************************************************************************************
// команды bash**************************************************************************************
// cd	Перемещение в домашний каталог
// cd ~	Перемещение в домашний каталог
// cd ..	Перемещение на один уровень выше
// cd -	Перемещение в предыдущий каталог
// cd Directory1	Перемещение в каталог Directory1
// cd Directory1/Directory2	Перемещение в каталог Directory2 по указанному пути