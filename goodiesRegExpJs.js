//регулярные выражения*******************************************************
//***************************************************************************
var regexp = new RegExp("шаблон", "флаги");
var regexp = /шаблон/; // без флагов
var regexp = /шаблон/gmi; // с флагами gmi
/*Регулярное выражение состоит из шаблона и необязательных флагов g, i и m.
Поиск по регулярному выражению без флагов и спец. символов, которые мы изучим далее – это то же самое, 
что и обычный поиск подстроки в строке. Но флаги и спец. символы, как мы увидим далее, могут сделать его гораздо мощнее.
Метод строки str.search(regexp) возвращает индекс, на котором найдено совпадение.*/
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************

// str.search(reg)****************************************************************************************************
// Он возвращает позицию первого совпадения или -1, если ничего не найдено.
var str = "Люблю регэкспы я, но странною любовью";

alert( str.search( /лю/i ) ); // 0
// Ограничение метода search – он всегда ищет только первое совпадение.
// Нельзя заставить search искать дальше первого совпадения, такой синтаксис попросту не предусмотрен. Но есть другие методы, которые это умеют.

// str.match(reg) без флага g *****************************************************************************************
/*Метод str.match работает по-разному, в зависимости от наличия или отсутствия флага g, поэтому сначала мы разберём вариант, когда его нет.
В этом случае str.match(reg) находит только одно, первое совпадение.
Результат вызова – это массив, состоящий из этого совпадения, с дополнительными свойствами index – позиция, на которой оно обнаружено и input – строка, в которой был поиск.*/

var str = "ОЙ-Ой-ой";

var result = str.match( /ой/i );

alert( result[0] ); // ОЙ  (совпадение)
alert( result.index ); // 0 (позиция)
alert( result.input ); // ОЙ-Ой-ой (вся поисковая строка)

/*У этого массива не всегда только один элемент.
Если часть шаблона обозначена скобками, то она станет отдельным элементом массива.*/

var str = "javascript - это такой язык";

var result = str.match( /JAVA(SCRIPT)/i );

alert( result[0] ); // javascript (всё совпадение полностью)
alert( result[1] ); // script (часть совпадения, соответствующая скобкам)
alert( result.index ); // 0
alert( result.input ); // javascript - это такой язык

/*Благодаря флагу i поиск не обращает внимание на регистр буквы, поэтому находит javascript. При этом часть строки, соответствующая SCRIPT, выделена в отдельный элемент массива.
Позже мы ещё вернёмся к скобочным выражениям, они особенно удобны для поиска с заменой.*/

// str.match(reg) с флагом g *************************************************************************************
/*При наличии флага g, вызов match возвращает обычный массив из всех совпадений.
Никаких дополнительных свойств у массива в этом случае нет, скобки дополнительных элементов не порождают.*/

var str = "ОЙ-Ой-ой";
var result = str.match( /ой/ig );

alert( result ); // ОЙ, Ой, ой
// Пример со скобками:
var str = "javascript - это такой язык";

var result = str.match( /JAVA(SCRIPT)/gi );

alert( result[0] ); // javascript
alert( result.length ); // 1
alert( result.index ); // undefined

/*Из последнего примера видно, что элемент в массиве ровно один, и свойства index также нет. 
Такова особенность глобального поиска при помощи match – он просто возвращает все совпадения.
Для расширенного глобального поиска, который позволит получить все позиции и, при желании, скобки, нужно использовать метод RegExp#exec, которые будет рассмотрен далее.
В случае, если совпадений не было, match возвращает null
Обратите внимание, это важно – если match не нашёл совпадений, он возвращает не пустой массив, а именно null.
Это важно иметь в виду, чтобы не попасть в такую ловушку:*/

 var str = "Ой-йой-йой";

// результат match не всегда массив!
alert(str.match(/лю/gi).length) // ошибка! нет свойства length у null

// str.split(reg|substr, limit)***************************************************************************************
/*Разбивает строку в массив по разделителю – регулярному выражению regexp или подстроке substr.
Обычно мы используем метод split со строками, вот так:*/

alert('12-34-56'.split('-')) // [12, 34, 56]
// Можно передать в него и регулярное выражение, тогда он разобьёт строку по всем совпадениям.

// Тот же пример с регэкспом:

alert('12-34-56'.split(/-/)) // [12, 34, 56]

// str.replace(reg, str|func)**************************************************************************************
/*Швейцарский нож для работы со строками, поиска и замены любого уровня сложности.
Его простейшее применение – поиск и замена подстроки в строке, вот так:*/

 // заменить дефис на двоеточие
alert('12-34-56'.replace("-", ":")) // 12:34-56
/*При вызове со строкой замены replace всегда заменяет только первое совпадение.
Чтобы заменить все совпадения, нужно использовать для поиска не строку "-", а регулярное выражение /-/g, причём обязательно с флагом g:*/

// заменить дефис на двоеточие
alert( '12-34-56'.replace( /-/g, ":" ) )  // 12:34:56
/*В строке для замены можно использовать специальные символы:

Спецсимволы	Действие в строке замены
$$	Вставляет "$".
$&	Вставляет всё найденное совпадение.
$`	Вставляет часть строки до совпадения.
$'	Вставляет часть строки после совпадения.
$*n*	где n -- цифра или двузначное число, обозначает n-ю по счёту скобку, если считать слева-направо.
Пример использования скобок и $1, $2:*/

var str = "Василий Пупкин";

alert(str.replace(/(Василий) (Пупкин)/, '$2, $1')) // Пупкин, Василий
// Ещё пример, с использованием $&:

var str = "Василий Пупкин";

alert(str.replace(/Василий Пупкин/, 'Великий $&!')) // Великий Василий Пупкин!
/*Для ситуаций, которые требуют максимально «умной» замены, в качестве второго аргумента предусмотрена функция.
Она будет вызвана для каждого совпадения, и её результат будет вставлен как замена.*/

var i = 0;

// заменить каждое вхождение "ой" на результат вызова функции
alert("ОЙ-Ой-ой".replace(/ой/gi, function() {
  return ++i;
})); // 1-2-3
/*В примере выше функция просто возвращала числа по очереди, но обычно она основывается на поисковых данных.
Эта функция получает следующие аргументы:

str – найденное совпадение,
p1, p2, ..., pn – содержимое скобок (если есть),
offset – позиция, на которой найдено совпадение,
s – исходная строка.
Если скобок в регулярном выражении нет, то у функции всегда будет ровно 3 аргумента: replacer(str, offset, s).

Используем это, чтобы вывести полную информацию о совпадениях:*/

 // вывести и заменить все совпадения
function replacer(str, offset, s) {
  alert( "Найдено: " + str + " на позиции: " + offset + " в строке: " + s );
  return str.toLowerCase();
}

var result = "ОЙ-Ой-ой".replace(/ой/gi, replacer);
alert( 'Результат: ' + result ); // Результат: ой-ой-ой
// С двумя скобочными выражениями – аргументов уже 5:

 function replacer(str, name, surname, offset, s) {
  return surname + ", " + name;
}

var str = "Василий Пупкин";

alert(str.replace(/(Василий) (Пупкин)/, replacer)) // Пупкин, Василий
// Функция – это самый мощный инструмент для замены, какой только может быть. Она владеет всей информацией о совпадении и имеет доступ к замыканию, поэтому может всё.

// regexp.test(str)*****************************************************************************************
/*Теперь переходим к методам класса RegExp.
Метод test проверяет, есть ли хоть одно совпадение в строке str. Возвращает true/false.
Работает, по сути, так же, как и проверка str.search(reg) != -1, например:*/

var str = "Люблю регэкспы я, но странною любовью";

// эти две проверки идентичны
alert( /лю/i.test(str) ) // true
alert( str.search(/лю/i) != -1 ) // true
// Пример с отрицательным результатом:

var str = "Ой, цветёт калина...";

alert( /javascript/i.test(str) ) // false
alert( str.search(/javascript/i) != -1 ) // false

// regexp.exec(str)*****************************************************************************************************
/*Для поиска мы уже видели методы:

search – ищет индекс
match – если регэксп без флага g – ищет совпадение с подрезультатами в скобках
match – если регэксп с флагом g – ищет все совпадения, но без скобочных групп.
Метод regexp.exec дополняет их. Он позволяет искать и все совпадения и скобочные группы в них.

Он ведёт себя по-разному, в зависимости от того, есть ли у регэкспа флаг g.

Если флага g нет, то regexp.exec(str) ищет и возвращает первое совпадение, является полным аналогом вызова str.match(reg).
Если флаг g есть, то вызов regexp.exec возвращает первое совпадение и запоминает его позицию в свойстве regexp.lastIndex. Последующий поиск он начнёт уже с этой позиции. Если совпадений не найдено, то сбрасывает regexp.lastIndex в ноль.
Это используют для поиска всех совпадений в цикле:*/

var str = 'Многое по JavaScript можно найти на сайте http://javascript.ru';

var regexp = /javascript/ig;
var result;

alert( "Начальное значение lastIndex: " + regexp.lastIndex );

while (result = regexp.exec(str)) {
  alert( 'Найдено: ' + result[0] + ' на позиции:' + result.index );
  alert( 'Свойство lastIndex: ' + regexp.lastIndex );
}

alert( 'Конечное значение lastIndex: ' + regexp.lastIndex );
/*Здесь цикл продолжается до тех пор, пока regexp.exec не вернёт null, что означает «совпадений больше нет».
Найденные результаты последовательно помещаются в result, причём находятся там в том же формате, что и match – с учётом скобок, со свойствами result.index и result.input.
Поиск с нужной позиции
Можно заставить regexp.exec искать сразу с нужной позиции, если поставить lastIndex вручную:*/

 var str = 'Многое по JavaScript можно найти на сайте http://javascript.ru';

var regexp = /javascript/ig;
regexp.lastIndex = 40;

alert( regexp.exec(str).index ); // 49, поиск начат с 40-й позиции

/*Итого, рецепты
Методы становятся гораздо понятнее, если разбить их использование по задачам, которые нужны в реальной жизни.

Для поиска только одного совпадения:
Найти позицию первого совпадения – str.search(reg).
Найти само совпадение – str.match(reg).
Проверить, есть ли хоть одно совпадение – regexp.test(str) или str.search(reg) != -1.
Найти совпадение с нужной позиции – regexp.exec(str), начальную позицию поиска задать в regexp.lastIndex.
Для поиска всех совпадений:
Найти массив совпадений – str.match(reg), с флагом g.
Получить все совпадения, с подробной информацией о каждом – regexp.exec(str) с флагом g, в цикле.
Для поиска-и-замены: : - Замена на другую строку или результат функции -- `str.replace(reg, str|func)`
Для разбивки строки на части:
str.split(str|reg)
Зная эти методы, мы уже можем использовать регулярные выражения.

Конечно, для этого желательно хорошо понимать их синтаксис и возможности, так что переходим к ним дальше.*/
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
/*Важнейшие классы: \d \s \w*****************************************************************************************

\d (от английского «digit» – «цифра»)
Цифра, символ от 0 до 9.
\s (от английского «space» – «пробел»)
Пробельный символ, включая табы, переводы строки и т.п.
\w (от английского «word» – «слово»)
Символ «слова», а точнее – буква латинского алфавита или цифра или подчёркивание '_'. Не-английские буквы не являются \w, то есть русская буква не подходит.
Например, \d\s\w обозначает цифру, за которой идёт пробельный символ, а затем символ слова.

Регулярное выражение может содержать одновременно и обычные символы и классы.

Например, CSS\d найдёт строку CSS, с любой цифрой после неё:*/

var str = "Стандарт CSS4 - это здорово";
var reg = /CSS\d/

alert( str.match(reg) ); // CSS4
// И много классов подряд:

alert( "Я люблю HTML5!".match(/\s\w\w\w\w\d/) ); // 'HTML5'

// Граница слова \b*****************************************************************************************

/*Граница слова \b – это особый класс.
Он интересен тем, что обозначает не символ, а границу между символами.
Например, \bJava\b найдёт слово Java в строке Hello, Java!, но не в строке Hello, Javascript!.*/

alert( "Hello, Java!".match(/\bJava\b/) ); // Java
alert( "Hello, Javascript!".match(/\bJava\b/) ); // null
/*Граница имеет «нулевую ширину» в том смысле, что обычно символам регулярного выражения соответствуют символы строки, но не в этом случае.
Граница – это проверка.
При поиске движок регулярных выражений идёт по шаблону и одновременно по строке, пытаясь построить соответствие. Когда он видит \b, то проверяет, что текущая позиция в строке подходит под одно из условий:
Начало текста, если первый символ \w.
Конец текста, если последний символ \w.
Внутри текста, если с одной стороны \w, а с другой – не \w.
Как правило, \b используется, чтобы искать отдельно стоящее слово. Не на русском конечно, хотя подобную проверку, как мы увидим далее, можно легко сделать для любого языка. 
А вот на английском, как в примере выше или для чисел, которые являются частным случаем \w – легко.
Например, регэксп \b\d\d\b ищет отдельно двузначные числа. Иными словами, он требует, чтобы до и после \d\d был символ, отличный от \w (или начало/конец текста).*/

// Экранирование специальных символов************************************************************************************
/*В регулярных выражениях есть и другие символы, имеющие особый смысл.
Они используются, чтобы расширить возможности поиска.
Вот их полный список: [ \ ^ $ . | ? * + ( ).
Не пытайтесь запомнить его – когда мы разберёмся с каждым из них по отдельности, он запомнится сам собой.
Чтобы использовать специальный символ в качестве обычного, он должен быть экранирован.
Или, другими словами, перед символом должен быть обратный слэш '\'.
Например, нам нужно найти точку '.'. В регулярном выражении она означает «любой символ, кроме новой строки», поэтому чтобы найти именно сам символ «точка» – её нужно экранировать: \..*/

alert( "Глава 5.1".match(/\d\.\d/) ); // 5.1
// Круглые скобки также являются специальными символами, так что для поиска именно скобки нужно использовать \(. Пример ниже ищет строку "g()":

alert( "function g()".match(/g\(\)/) ); // "g()"
// Сам символ слэш '/', хотя и не является специальными символом в регулярных выражениях, но открывает-закрывает регэксп в синтаксисе /...pattern.../, поэтому его тоже нужно экранировать.

// Так выглядит поиск слэша '/':

 alert( "/".match(/\//) ); // '/'
// Ну и, наконец, если нам нужно найти сам обратный слэш \, то его нужно просто задублировать.

// Так выглядит поиск обратного слэша "\":

alert( "1\2".match(/\\/) ); // '\'

/*Мы рассмотрели классы для поиска типов символов:

\d – цифры.
\D – не-цифры.
\s – пробельные символы, переводы строки.
\S – всё, кроме \s.
\w – латинница, цифры, подчёркивание '_'.
\W – всё, кроме \w.
'.' – точка обозначает любой символ, кроме перевода строки.
Если хочется поискать именно сочетание "\d" или символ «точка», то его экранируют обратным слэшем, вот так: \.

Заметим, что регулярное выражение может также содержать перевод строки \n, табуляцию \t и прочие спецсимволы для строк. Конфликта с классами не происходит, так как для них зарезервированы другие буквы.*/
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
// Набор********************************************************************************************
/*Например, [еао] означает любой символ из этих трёх: 'а', 'е', или 'о'.
Такое обозначение называют набором. Наборы используются в регулярном выражении наравне с обычными символами:*/

 // найти [г или т], а затем "оп"
alert( "Гоп-стоп".match(/[гт]оп/gi) ); // "Гоп", "топ"
/*Обратим внимание: несмотря на то, что в наборе указано несколько символов, в совпадении должен присутствовать ровно один из них.
Поэтому в примере ниже нет результатов:*/

 // найти "В", затем [у или а], затем "ля"
alert( "Вуаля".match(/В[уа]ля/) ); // совпадений нет
/*Поиск подразумевает:

В,
затем одну из букв набора [уа],
а затем ля
Таким образом, совпадение было бы для строки Вуля или Валя.*/

// Диапазоны***************************************************************************************************************
/*Квадратные скобки могут также содержать диапазоны символов.
Например, [a-z] – произвольный символ от a до z, [0-5] – цифра от 0 до 5.
В примере ниже мы будем искать "x", после которого идёт два раза любая цифра или буква от A до F:*/

 // найдёт "xAF"
alert( "Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g) );
/*Обратим внимание, в слове Exception есть сочетание xce, но оно не подошло, потому что буквы в нём маленькие, а в диапазоне [0-9A-F] – большие.
Если хочется искать и его тоже, можно добавить в скобки диапазон a-f: [0-9A-Fa-f]. Или же просто указать у всего регулярного выражения флаг i.
Символьные классы – всего лишь более короткие записи для диапазонов, в частности:

\d – то же самое, что [0-9],
\w – то же самое, что [a-zA-Z0-9_],
\s – то же самое, что [\t\n\v\f\r ] плюс несколько юникодных пробельных символов.
В квадратных скобках можно использовать и диапазоны и символьные классы – вместе.

Например, нам нужно найти все слова в тексте. Если они на английском – это достаточно просто:*/

var str = "The sun is rising!";

alert( str.match(/\w+/g) ); // The, sun, is, rising
/*В этом примере мы забежали немного вперёд и использовали pattern\w+, что означает один или более символов, подходящих под классpattern\w. 
Позже мы рассмотрим + детальнее, а пока – давайте посмотрим, найдутся ли слова на русском?*/

var str = "Солнце встаёт!";

alert( str.match(/\w+/g) ); // null
/*Ничего не найдено! Это можно понять, ведь \w – это именно английская букво-цифра, как можно видеть из аналога [a-zA-Z0-9_].
Чтобы находило слово на русском – нужно использовать диапазон, например /[а-я]/.
А чтобы на обоих языках – и то и другое вместе:*/

var str = "Солнце (the sun) встаёт!";

alert( str.match(/[\wа-я]+/gi) ); // Солнце, the, sun, вста, т
/*Присмотритесь внимательно к предыдущему примеру! Вы видите странность? Оно не находит букву ё, более того – считает её разрывом в слове. Причина – в кодировке юникод, она подробно раскрыта в главе Строки.
Буква ё лежит в стороне от основной кириллицы и её следует добавить в диапазон дополнительно, вот так:*/

var str = "Солнце (the sun) встаёт!";

alert( str.match(/[\wа-яё]+/gi) ); // Солнце, the, sun, встаёт
// Теперь всё в порядке.

// Диапазоны «кроме»************************************************************************************************************************************
/*Кроме обычных, существуют также исключающие диапазоны: [^…].
Квадратные скобки, начинающиеся со знака каретки: [^…] находят любой символ, кроме указанных.

[^аеуо] – любой символ, кроме 'a', 'e', 'y', 'o'.
[^0-9] – любой символ, кроме цифры, то же что \D.
[^\s] – любой не-пробельный символ, то же что \S.
Пример ниже ищет любые символы, кроме букв, цифр и пробелов:*/

alert( "alice15@gmail.com".match(/[^\d\sA-Z]/gi) ); // "@", "."

// Не нужно экранирование***********************************************************************************************************************************
/*Обычно, если мы хотим искать именно точку, а не любой символ, или именно символ \, то мы используем экранирование: указываем \. или \\.
В квадратных скобках большинство специальных символов можно использовать без экранирования, если конечно они не имеют какой-то особый смысл именно внутри квадратных скобок.
То есть, «как есть», без экранирования можно использовать символы:

Точка '.'.
Плюс '+'.
Круглые скобки '( )'.
Дефис '-', если он находится в начале или конце квадратных скобок, то есть не выделяет диапазон.
Символ каретки '^', если не находится в начале квадратных скобок.
А также открывающая квадратная скобка '['.
То есть, точка "." в квадратных скобках означает не «любой символ», а обычную точку.*/

/*Регэксп [.,] ищет один из символов «точка» или «запятая».
В примере ниже регэксп [-().^+] ищет один из символов -().^. Они не экранированы:*/

 // Без экранирования
var re = /[-().^+]/g;

alert( "1 + 2 - 3".match(re) ); // найдёт +, -
// Впрочем, даже если вы решите «на всякий случай» заэкранировать эти символы, поставив перед ними обратный слэш \ – вреда не будет:

 // Всё заэкранировали
var re = /[\-\(\)\.\^\+]/g;

alert( "1 + 2 - 3".match(re) ); // тоже работает: +, -
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
// Квантификаторы +, *, ? и {n}***********************************************************************************************************************
/*Рассмотрим ту же задачу, что и ранее – взять телефон вида +7(903)-123-45-67 и найти все числа в нём. 
Но теперь нас интересуют не цифры по отдельности, а именно числа, то есть результат вида 7, 903, 123, 45, 67.
Для поиска цифр по отдельности нам было достаточно класса \d. Но здесь нужно искать числа – последовательности из 1 или более цифр.*/
// Количество {n}***********************************************************************************************************************
/*Количество повторений символа можно указать с помощью числа в фигурных скобках: {n}.
Такое указание называют квантификатором (от англ. quantifier).
У него есть несколько подформ записи:
Точное количество: {5}
Регэксп \d{5} обозначает ровно 5 цифр, в точности как \d\d\d\d\d.
Следующий пример находит пятизначное число.*/

alert( "Мне 12345 лет".match(/\d{5}/) ); //  "12345"
/*Количество от-до: {3,5}
Для того, чтобы найти, например, числа размером от трёх до пяти знаков, нужно указать границы в фигурных скобках: \d{3,5}*/

 alert( "Мне не 12, а 1234 года".match(/\d{3,5}/) ); // "1234"
// Последнее значение можно и не указывать. Тогда выражение \d{3,} найдет числа, длиной от трех цифр:

 alert( "Мне не 12, а 345678 лет".match(/\d{3,}/) ); // "345678"
// В случае с телефоном нам нужны числа – одна или более цифр подряд. Этой задаче соответствует регулярное выражение \d{1,}:

 var str = "+7(903)-123-45-67";

alert( str.match(/\d{1,}/g) ); // 7,903,123,45,67
// Короткие обозначения***********************************************************************************************************************
Для самых часто востребованных квантификаторов есть специальные короткие обозначения.

+
Означает «один или более», то же что {1,}.

Например, \d+ находит числа – последовательности из 1 или более цифр:

var str = "+7(903)-123-45-67";

alert( str.match(/\d+/g) ); // 7,903,123,45,67
?
Означает «ноль или один», то же что и {0,1}. По сути, делает символ необязательным.

Например, регэксп ou?r найдёт o, после которого, возможно, следует u, а затем r.

Этот регэксп найдёт or в слове color и our в colour:

 var str = "Можно писать color или colour (британский вариант)";

alert( str.match(/colou?r/g) ); // color, colour
*
Означает «ноль или более», то же что {0,}. То есть, символ может повторяться много раз или вообще отсутствовать.

Пример ниже находит цифру, после которой идёт один или более нулей:

alert( "100 10 1".match(/\d0*/g) ); // 100, 10, 1
Сравните это с '+' (один или более):

alert( "100 10 1".match(/\d0+/g) ); // 100, 10
// Ещё примеры

Эти квантификаторы принадлежат к числу самых важных «строительных блоков» для сложных регулярных выражений, поэтому мы рассмотрим ещё примеры.

Регэксп «десятичная дробь» (число с точкой внутри): \d+\.\d+
В действии:

 alert( "0 1 12.345 7890".match(/\d+\.\d+/g) ); // 12.345
Регэксп «открывающий HTML-тег без атрибутов», такой как <span> или <p>: /<[a-z]+>/i
Пример:

 alert( "<BODY> ... </BODY>".match(/<[a-z]+>/gi) ); // <BODY>
Это регулярное выражение ищет символ '<', за которым идут одна или более букв английского алфавита, и затем '>'.

Регэксп «открывающий HTML-тег без атрибутов» (лучше): /<[a-z][a-z0-9]*>/i
Здесь регулярное выражение расширено: в соответствие со стандартом, HTML-тег может иметь символ цифры на любой позиции, кроме первой, например <h1>.

 alert( "<h1>Привет!</h1>".match(/<[a-z][a-z0-9]*>/gi) ); // <h1>
Регэксп «открывающий или закрывающий HTML-тег без атрибутов»: /<\/?[a-z][a-z0-9]*>/i
В предыдущий паттерн добавили необязательный слэш /? перед тегом. Его понадобилось заэкранировать, чтобы JavaScript не принял его за конец шаблона.

 alert( "<h1>Привет!</h1>".match(/<\/?[a-z][a-z0-9]*>/gi) ); // <h1>, </h1>
Точнее – значит сложнее
В этих примерах мы видим общее правило, которое повторяется из раза в раз: чем точнее регулярное выражение, тем оно длиннее и сложнее.

Например, для HTML-тегов, скорее всего, подошло бы и более короткое регулярное выражение <\w+>.

Так как класс \w означает "любая цифра или английская буква или '_', то под такой регэксп подойдут и не теги, например <_>. Однако он гораздо проще, чем более точный регэксп <[a-z][a-z0-9]*>.

Подойдёт ли нам <\w+> или нужно использовать именно <[a-z][a-z0-9]*>?

В реальной жизни допустимы оба варианта. Ответ на подобные вопросы зависит от того, насколько реально важна точность и насколько сложно потом будет отфильтровать лишние совпадения (если появятся).

//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
// Квантификаторы имеют два режима работы:***********************************************************************************************************************
// Жадный
Режим по умолчанию – движок регулярных выражений повторяет его по-максимуму. Когда повторять уже нельзя, например нет больше цифр для \d+, 
он продолжает поиск с оставшейся части текста. Если совпадение найти не удалось – отступает обратно, уменьшая количество повторений.
// Ленивый
При указании после квантификатора символа ? он работает в ленивом режиме. То есть, он перед каждым повторением проверяет совпадение оставшейся части шаблона на текущей позиции.
Как мы видели в примере выше, ленивый режим – не панацея от «слишком жадного» забора символов. Альтернатива – более аккуратно настроенный «жадный», с исключением символов. 
Как мы увидим далее, можно исключать не только символы, но и целые подшаблоны.

// Альтернативный подход*****************************************************************
В данном конкретном случае, возможно искать строки в кавычках, оставаясь в жадном режиме, с использованием регулярного выражения "[^"]+":

var reg = /"[^"]+"/g;

var str = 'a "witch" and her "broom" is one';

alert( str.match(reg) ); // witch, broom
Регэксп "[^"]+" даст правильные результаты, поскольку ищет кавычку '"', за которой идут столько не-кавычек (исключающие квадратные скобки), сколько возможно.
Так что вторая кавычка автоматически прекращает повторения [^"]+ и позволяет найти остаток шаблона ".
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
// Скобочные группы***************************************************************************************
/*Часть шаблона может быть заключена в скобки (...). Такие выделенные части шаблона называют «скобочными выражениями» или «скобочными группами».
У такого выделения есть два эффекта:
Он позволяет выделить часть совпадения в отдельный элемент массива при поиске через String#match или RegExp#exec.
Если поставить квантификатор после скобки, то он применится ко всей скобке, а не всего лишь к одному символу.
Пример

В примере ниже, шаблон (go)+ находит один или более повторяющихся 'go':*/

alert( 'Gogogo now!'.match(/(go)+/i) ); // "Gogogo"
/*Без скобок, шаблон /go+/ означал бы g, после которого идёт одна или более o, например: goooo. А скобки «группируют» (go) вместе.

Содержимое группы
Скобки нумеруются слева направо. Поисковой движок запоминает содержимое каждой скобки и позволяет обращаться к нему – в шаблоне и строке замены и, конечно же, в результатах.
Например, найти HTML-тег можно шаблоном <.*?>.
После поиска мы захотим что-то сделать с результатом. Для удобства заключим содержимое <...> в скобки: <(.*?)>. Тогда оно будет доступно отдельно.
При поиске методом String#match в результирующем массиве будет сначала всё совпадение, а далее – скобочные группы. В шаблоне <(.*?)> скобочная группа только одна:*/

 var str = '<h1>Привет, мир!</h1>';
var reg = /<(.*?)>/;

alert( str.match(reg) ); // массив: <h1>, h1
/*Заметим, что метод String#match выдаёт скобочные группы только при поиске без флага /.../g. В примере выше он нашёл только первое совпадение <h1>, 
а закрывающий </h1> не нашёл, поскольку без флага /.../g ищется только первое совпадение.
Для того, чтобы искать и с флагом /.../g и со скобочными группами, используется метод RegExp#exec:*/

 var str = '<h1>Привет, мир!</h1>';
var reg = /<(.*?)>/g;

var match;

while ((match = reg.exec(str)) !== null) {
  // сначала выведет первое совпадение: <h1>,h1
  // затем выведет второе совпадение: </h1>,/h1
  alert(match);
}
// Теперь найдено оба совпадения <(.*?)>, каждое – массив из полного совпадения и скобочных групп (одна в данном случае).

// Содержимое группы****************************************************************************************
/*Скобки нумеруются слева направо. Поисковой движок запоминает содержимое каждой скобки и позволяет обращаться к нему – в шаблоне и строке замены и, конечно же, в результатах.
Например, найти HTML-тег можно шаблоном <.*?>.
После поиска мы захотим что-то сделать с результатом. Для удобства заключим содержимое <...> в скобки: <(.*?)>. Тогда оно будет доступно отдельно.
При поиске методом String#match в результирующем массиве будет сначала всё совпадение, а далее – скобочные группы. В шаблоне <(.*?)> скобочная группа только одна:*/

var str = '<h1>Привет, мир!</h1>';
var reg = /<(.*?)>/;

alert( str.match(reg) ); // массив: <h1>, h1
/*Заметим, что метод String#match выдаёт скобочные группы только при поиске без флага /.../g. 
В примере выше он нашёл только первое совпадение <h1>, а закрывающий </h1> не нашёл, поскольку без флага /.../g ищется только первое совпадение.
Для того, чтобы искать и с флагом /.../g и со скобочными группами, используется метод RegExp#exec:*/

var str = '<h1>Привет, мир!</h1>';
var reg = /<(.*?)>/g;

var match;

while ((match = reg.exec(str)) !== null) {
  // сначала выведет первое совпадение: <h1>,h1
  // затем выведет второе совпадение: </h1>,/h1
  alert(match);
}
// Теперь найдено оба совпадения <(.*?)>, каждое – массив из полного совпадения и скобочных групп (одна в данном случае).

// Вложенные группы***********************************************************************************************
/*Скобки могут быть и вложенными. В этом случае нумерация также идёт слева направо.
Например, при поиске тега в <span class="my"> нас может интересовать:

Содержимое тега целиком: span class="my".
В отдельную переменную для удобства хотелось бы поместить тег: span.
Также может быть удобно отдельно выделить атрибуты class="my".
Добавим скобки в регулярное выражение:*/

var str = '<span class="my">';

var reg = /<(([a-z]+)\s*([^>]*))>/;

alert( str.match(reg) ); // <span class="my">, span class="my", span, class="my"

/*На нулевом месте – всегда совпадение полностью, далее – группы. Нумерация всегда идёт слева направо, по открывающей скобке.
В данном случае получилось, что группа 1 включает в себя содержимое групп 2 и 3. Это совершенно нормальная ситуация, которая возникает, когда нужно выделить что-то отдельное внутри большей группы.
Даже если скобочная группа необязательна и не входит в совпадение, соответствующий элемент массива существует (и равен undefined).
Например, рассмотрим регэксп a(z)?(c)?. Он ищет "a", за которой не обязательно идёт буква "z", за которой необязательно идёт буква "c".
Если напустить его на строку из одной буквы "a", то результат будет таков:*/

var match = 'a'.match(/a(z)?(c)?/)

alert( match.length ); // 3
alert( match[0] ); // a
alert( match[1] ); // undefined
alert( match[2] ); // undefined
/*Массив получился длины 3, но все скобочные группы – undefined.
А теперь более сложная ситуация, строка ack:*/

var match = 'ack'.match(/a(z)?(c)?/)

alert( match.length ); // 3
alert( match[0] ); // ac, всё совпадение
alert( match[1] ); // undefined, для (z)? ничего нет
alert( match[2] ); // c
// Длина массива результатов по-прежнему 3. Она постоянна. А вот для скобочной группы (z)? в ней ничего нет, поэтому результат: ["ac", undefined, "c"].

// Исключение из запоминания через ?:********************************************************************************************************
/*Бывает так, что скобки нужны, чтобы квантификатор правильно применился, а вот запоминать их содержимое в массиве не нужно.
Скобочную группу можно исключить из запоминаемых и нумеруемых, добавив в её начало ?:.
Например, мы хотим найти (go)+, но содержимое скобок (go) в отдельный элемент массива выделять не хотим.
Для этого нужно сразу после открывающей скобки поставить ?:, то есть: (?:go)+.*/

var str = "Gogo John!";
var reg = /(?:go)+ (\w+)/i;

var result = str.match(reg);

alert( result.length ); // 2
alert( result[1] ); // John
// В примере выше массив результатов имеет длину 2 и содержит только полное совпадение и результат (\w+). Это удобно в тех случаях, когда содержимое скобок нас не интересует.
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
// Обратные ссылки: \n и $n****************************************************************************************************
Скобочные группы можно не только получать в результате.
Движок регулярных выражений запоминает их содержимое, и затем его можно использовать как в самом паттерне, так и в строке замены.
// Группа в строке замены***************************************************************************
Ссылки в строке замены имеют вид $n, где n – это номер скобочной группы.
Вместо $n подставляется содержимое соответствующей скобки:
var name = "Александр Пушкин";

name = name.replace(/([а-яё]+) ([а-яё]+)/i, "$2, $1");
alert( name ); // Пушкин, Александр
В примере выше вместо $2 подставляется второе найденное слово, а вместо $1 – первое.

// Группа в шаблоне**********************************************************************************
Выше был пример использования содержимого групп в строке замены. Это удобно, когда нужно реорганизовать содержимое или создать новое с использованием старого.
Но к скобочной группе можно также обратиться в самом поисковом шаблоне, ссылкой вида \номер.
Чтобы было яснее, рассмотрим это на реальной задаче – необходимо найти в тексте строку в кавычках. Причём кавычки могут быть одинарными '...' или двойными "..." – и то и другое должно искаться корректно.
Как такие строки искать?
Можно в регэкспе предусмотреть произвольные кавычки: ['"](.*?)['"]. Такой регэксп найдёт строки вида "...", '...', но он даст неверный ответ в случае, 
если одна кавычка ненароком оказалась внутри другой, как например в строке "She's the one!":

var str = "He said: \"She's the one!\".";

var reg = /['"](.*?)['"]/g;

// Результат не соответствует замыслу
alert( str.match(reg) ); // "She'
Как видно, регэксп нашёл открывающую кавычку ", затем текст, вплоть до новой кавычки ', которая закрывает соответствие.
Для того, чтобы попросить регэксп искать закрывающую кавычку – такую же, как открывающую, мы обернём её в скобочную группу и используем обратную ссылку на неё:

var str = "He said: \"She's the one!\".";

var reg = /(['"])(.*?)\1/g;

alert( str.match(reg) ); // "She's the one!"
Теперь работает верно! Движок регулярных выражений, найдя первое скобочное выражение – кавычку (['"]), запоминает его и далее \1 означает «найти то же самое, что в первой скобочной группе».
Обратим внимание на два нюанса:
Чтобы использовать скобочную группу в строке замены – нужно использовать ссылку вида $1, а в шаблоне – обратный слэш: \1.
Чтобы в принципе иметь возможность обратиться к скобочной группе – не важно откуда, она не должна быть исключена из запоминаемых при помощи ?:. Скобочные группы вида (?:...) не участвуют в нумерации.
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
// Альтернация (или) |**************************************************************************************************
Альтернация – термин в регулярных выражениях, которому в русском языке соответствует слово «ИЛИ». Она обозначается символом вертикальной черты | и позволяет выбирать между вариантами.
Например, нам нужно найти языки программирования: HTML, PHP, Java и JavaScript.
Соответствующее регулярное выражение: html|php|java(script)?.

var reg = /html|php|css|java(script)?/gi

var str = "Сначала появился HTML, затем CSS, потом JavaScript"

alert( str.match(reg) ) // 'HTML', 'CSS', 'JavaScript'
Мы уже знаем похожую вещь – квадратные скобки. Они позволяют выбирать между символами, например gr[ae]y найдёт gray, либо grey.
Альтернация работает уже не посимвольно, а на уровне фраз и подвыражений. Регэксп A|B|C обозначает поиск одного из выражений:
A, B или C, причём в качестве выражений могут быть другие, сколь угодно сложные регэкспы.
Для указания границ альтернации используют скобки (...), например: before(XXX|YYY)after будет искать beforeXXXafter или beforeYYYafter.
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
// Начало строки ^ и конец $**********************************************************************************************
Знак каретки '^' и доллара '$' имеют в регулярном выражении особый смысл. Их называют «якорями» (anchor – англ.).
Каретка ^ совпадает в начале текста, а доллар $ – в конце.
Якоря являются не символами, а проверками.
До этого мы говорили о регулярных выражениях, которые ищут один или несколько символов. Если совпадение есть – эти символы включаются в результат.
А якоря – не такие. Когда поиск ходит до якоря – он проверяет, есть ли соответствие, если есть – продолжает идти по шаблону, не прибавляя ничего к результату.
Каретку ^ обычно используют, чтобы указать, что регулярное выражение необходимо проверить именно с начала текста.

Например, без каретки найдёт все числа:

var str = '100500 попугаев съели 500100 бананов!';
alert( str.match(/\d+/ig) ); // 100500, 500100 (нашло все числа)
А с кареткой – только первое:

var str = '100500 попугаев съели 500100 бананов!';
alert( str.match(/^\d+/ig) ); // 100500 (только в начале строки)
Знак доллара $ используют, чтобы указать, что паттерн должен заканчиваться в конце текста.
Аналогичный пример с долларом для поиска числа в конце:

var str = '100500 попугаев съели 500100';
alert( str.match(/\d+$/ig) ); // 500100
Оба якоря используют одновременно, если требуется, чтобы шаблон охватывал текст с начала и до конца. Обычно это требуется при валидации.
Например, мы хотим проверить, что в переменной num хранится именно десятичная дробь.
Ей соответствует регэксп \d+\.\d+. Но простой поиск найдёт дробь в любом тексте:

var num = "ля-ля 12.34";
alert( num.match(/\d+\.\d+/ig) ); // 12.34
Наша же задача – проверить, что num целиком соответствует паттерну \d+\.\d+.
Для этого обернём шаблон в якоря ^...$:

var num = "ля-ля 12.34";
alert( num.match(/^\d+\.\d+$/ig) ); // null, не дробь

var num = "12.34";
alert( num.match(/^\d+\.\d+$/ig) ); // 12.34, дробь!
Теперь поиск ищет начало текста, за которым идёт число, затем точка, ещё число и конец текста. Это как раз то, что нужно.
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
// Многострочный режим, флаг "m"********************************************************************************
Многострочный режим включается, если у регэкспа есть флаг /m.
В этом случае изменяется поведение ^ и $.
В многострочном режиме якоря означают не только начало/конец текста, но и начало/конец строки.

Начало строки ^
В примере ниже текст состоит из нескольких строк. Паттерн /^\d+/gm берёт число с начала каждой строки:

var str = '1е место: Винни\n' +
  '2е место: Пятачок\n' +
  '33е место: Слонопотам';

alert( str.match(/^\d+/gm) ); // 1, 2, 33
Обратим внимание – без флага /m было бы найдено только первое число:

 var str = '1е место: Винни\n' +
  '2е место: Пятачок\n' +
  '33е место: Слонопотам';

alert( str.match(/^\d+/g) ); // 1
Это потому что в обычном режиме каретка ^ – это только начало текста, а в многострочном – начало любой строки.
Движок регулярных выражений двигается по тексту, и как только видит начало строки, начинает искать там \d+.

Конец строки $
Символ доллара $ ведёт себя аналогично.
Регулярное выражение [а-я]+$ в следующем примере находит последнее слово в каждой строке:

 var str = '1е место: Винни\n' +
  '2е место: Пятачок\n' +
  '33е место: Слонопотам';

alert( str.match(/[а-я]+$/gim) ); // Винни,Пятачок,Слонопотам
Без флага m якорь $ обозначал бы конец всего текста, и было бы найдено только последнее слово.

Якорь $ против \n
Для того, чтобы найти конец строки, можно использовать не только $, но и символ \n.
Но, в отличие от $, символ \n во-первых берёт символ в результат, а во-вторых – не совпадает в конце текста (если, конечно, последний символ – не конец строки).
Посмотрим, что будет с примером выше, если вместо [а-я]+$ использовать [а-я]+\n:

 var str = '1е место: Винни\n' +
  '2е место: Пятачок\n' +
  '33е место: Слонопотам';

alert( str.match(/[а-я]+\n/gim) );
/*
Винни
,Пятачок
*/
Всего два результата: Винни\n (с символом перевода строки) и Пятачок\n. Последнее слово «Слонопотам» здесь не даёт совпадения, так как после него нет перевода строки.

В мультистрочном режиме:

Символ ^ означает начало строки.
Символ $ означает конец строки.
Оба символа являются проверками, они не добавляют ничего к результату. Про них также говорят, что «они имеют нулевую длину».
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
// Предпросмотр*******************************************************************************************
x(?=y): 
Соответствует 'x' только если за 'x' следует 'y'. Это называется упреждение.
Например, /Jack(?=Sprat)/ соответствует 'Jack' только если за ним следует 'Sprat'. 
/Jack(?=Sprat|Frost)/ соответствует 'Jack' только если за ним следует 'Sprat' или 'Frost'. Тем не менее, ни 'Sprat' ни 'Frost' не являются частью сопоставленного результата.
x(?!y): 
Соответствует 'x' только если за 'x' не следует 'y'. Это называется отрицательное упреждение.
Например, /\d+(?!\.)/ соответствует числу только если за ним не следует десятичная точка. Регулярное выражение /\d+(?!\.)/.exec("3.141") сопоставит '141' но не '3.141'.
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//бэктрекинг*********************************************************************************************
Взятие максимального количества повторений a+ без отката выглядит так: (?=(a+))\1.
То есть, иными словами, предпросмотр ?= ищет максимальное количество повторений a+, доступных с текущей позиции.
А затем они «берутся в результат» обратной ссылкой \1. Дальнейший поиск – после найденных повторений.
Откат в этой логике в принципе не предусмотрен, поскольку предпросмотр «откатываться» не умеет. 
То есть, если предпросмотр нашёл 5 штук a+, и в результате поиск не удался, то он не будет откатываться на 4 повторения. Эта возможность в предпросмотре отсутствует, а в данном случае она как раз и не нужна.
Исправим регэксп для поиска тега с атрибутами <\w+(\s*\w+=(\w+|"[^"]*")\s*)*>, описанный в начале главы. Используем предпросмотр, чтобы запретить откат на меньшее количество пар атрибут=значение:

 // регэксп для пары атрибут=значение
var attr = /(\s*\w+=(\w+|"[^"]*")\s*)/

// используем его внутри регэкспа для тега
var reg = new RegExp('<\\w+(?=(' + attr.source + '*))\\1>', 'g');

var good = '...<a test="<>" href="#">... <b>...';

var bad = "<tag a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b\
  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b";

alert( good.match(reg) ); // <a test="<>" href="#">, <b>
alert( bad.match(reg) ); // null (нет результатов, быстро)
Отлично, всё работает! Нашло как длинный тег <a test="<>" href="#">, так и одинокий <b>.


//часто используемые регэкспы*******************************************************************************************
//**********************************************************************************************************************