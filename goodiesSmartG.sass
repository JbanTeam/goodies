//ненужно верстать по сетке меню и лого

//миксин добавления блока кода пишется без скобок
+md-block
	background-color: #fff
	display: flex
//*********************************************
.parent //сетка на флоатах
	+row-float()
	.item
		+col()
		+col-float()
		+size(3)
		+size-md(6)
		+size-sm(10)
		+offset-sm(1) //добавить офсет в 1 колонку
		+sizw-xs(12)
		+offset-xs(0) //убрать офсет
//******************************************************
//вложенная сетка, обязательно должна быть прослойка, иначе пропадет минусовый марджин
.parent
	+row-flex()
	.item
		+row-flex() //нельзя
		+col
		+size(6)
		.row //прослойка
			+row-flex()
			.child
				+col
				+size(6)
//*********************************************
//если элементы сетки должны соприкасаться
.parent
	+row-flex()
	.item
		+col-padding()
		&:nth-child(1)
			+size(4)
			padding-right: 0 //если схождение не в середине, убираем паддинг; если в середине убирать ненадо
			padding-left: 0 //убрать выступ с внешнего края
			margin-left: $offset_one_side //компенсировать марджином
		&:nth-child(2)
			+size(8)
			padding-left: $offset //если схождение не в середине, ставим двойной паддинг
			padding-right: 0 //убрать выступ с внешнего края
			margin-right: $offset_one_side //компенсировать марджином
//********************************************
//поддержка smartgrid

//flex % - us for android, ie9 не поддерживается
//calc flex(px, rem) - us for android, opera mini, ie9 не поддерживается

//float % - поддерживаются все
//calc float(px, rem) - opera mini

//функцию calc можно обойти задав свойство offset в %

//для ie9 создаем отдельный файл sass и вместо +row-flex - +row-float, и +col-float
//в gulpfile в сделать функцию конвертации style-ie9.sass в css
//style-ie9.css подключается условным комментарием <!--[if lte IE9]> <link rel="stylesheet" href="css/style-ie9.css" <![endif]-->
//можно также применять +row-ib и +col-ib
.blog-items
	+row-ib
	text-align: center
	font-size: 0 //обнуляем фонт сайз, чтобы убрать единичный пробел

.blog-item
	+col-ib
	font-size: 1rem //возвращаем фонт сайз у ребенка

//для ie11(не edge) не поддерживается свойства align-items и align-self(flexbox) и условный комментарий
//в местах где используется флекс выравниваем паддингом через эту хрень
@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {
	padding: 160px 0
}

//проверка поддержки функции calc в браузере
//функция checkCalc в goodiesJs.js

//*************************************************************************
//вертикальное выравнивание************************************************
//если текст в одну строку
.block
	height: 100px
	line-height: 100px
//************************************************************************
//можно использовать и с несколькими строками
.block
	display: table
	width: 100px
	.inner
		display: table-cell
		vertical-align: middle
//************************************************************************
//можно использовать и с несколькими строками
.block
	display: flex
	align-items: center
//************************************************************************
//элемент призрак
.block
	width: 100%
	height: 100%
	text-align: center
	.inner
		display: inline-block
		&:before
			content: ''
			height: 100%
			display: inline-block
			vertical-align: middle
//************************************************************************
//absolute
.block
	width: 300px
	height: 300px
	position: relative
	.inner
		position: absolute
		top: 50%
		left: 50%
		transform: translate(-50%, -50%)

//*************************************************************************
//css полезности***********************************************************

/* CSS-спрайты */

Этот трюк объединяет много картинок в одну, тем самым сокращая количество обращений к серверу. Например, чтобы получить 20 изображений для всех кнопок 
и логотипов вашего сайта (а это 20 HTTP-запросов, если не прибегать к спрайтам), вы просто объединяете все изображения в одно и всякий раз его размещаете. 
Чтобы была видна нужная часть, просто сдвигайте изображение на требуемое количество пикселей:


.icon {
  width: 16px;
  height: 16px;
  float: left;
  background: url(icons.gif) no-repeat;
}

.open .icon {
  background-position: 0 -16px; /* вверх на 16px */
  cursor: pointer;
}

.closed .icon {
  background-position: 0 0px; /* по умолчанию */
  cursor: pointer;
}

.leaf .icon {
  background-position: 0 -32px; /* вверх на 32px */
  cursor: text;
}

/* Улучшенный контроль */

Вы можете установить ширину переменной для абсолютно позиционированного элемента, указав оба свойства left и right. 
Это даст вам больше контроля, чем просто установка ширины в процентах:

#myElement {
    position: absolute;
    left: 5px;
    right: 10px;
}

Альтернативный пример:

#myElement{ /* заполнить все пространство :) */
   background: red;
   position:absolute;
   left: 0;
   right:0;
   top: 0;
   bottom: 0;
}

// Скроллбар без фрейма

Возможности CSS ориентированы на удобство написания, и этот способ – тому подтверждение. 
Вы можете создавать области прокрутки без использования фреймов. Делается это так:

div.foo {
    border:   1px solid;
    width:    300px;
    height:   300px;
    overflow: auto;
}

overflow: auto: если содержимое не может быть помещено в div, горизонтальные и/или вертикальные полосы прокрутки появятся по мере необходимости.
overflow: scroll: всегда будут видны обе полосы прокрутки. Если вы хотите, чтобы была только одна полоса, используйте overflow-x или overflow-y,
которые поддерживаются современными браузерами, в том числе IE6.
Предупреждение! Некоторые пользователи утверждают, что iPad и iPhone не поддерживают данный трюк: не отображается полоса прокрутки, и просто обрезается контент. 
Другие же говорят, что в iOS (точнее, в мобильном браузере Safari) все отображается нормально. Тестируйте!


//**********************************************************************
//Pixel Perfect
//расширение для хрома PixelPerfect by WellDoneCode; загружаем картинку и по ней верстаем

// **************************************************************************************
// CSS селекторы*************************************************************************
// Основных видов селекторов всего несколько:
// * – любые элементы.
// div – элементы с таким тегом.
// #id – элемент с данным id.
// .class – элементы с таким классом.
// [name="value"] – селекторы на атрибут (см. далее).
// :visited – «псевдоклассы», остальные разные условия на элемент (см. далее).
// Селекторы можно комбинировать, записывая последовательно, без пробела:
// .c1.c2 – элементы одновременно с двумя классами c1 и c2
// a#id.c1.c2:visited – элемент a с данным id, классами c1 и c2, и псевдоклассом visited

// В CSS3 предусмотрено четыре вида отношений между элементами.
// Самые известные вы наверняка знаете:
// div p – элементы p, являющиеся потомками div.
// div > p – только непосредственные потомки
// Есть и два более редких:
// div ~ p – правые соседи: все p на том же уровне вложенности, которые идут после div.
// div + p – первый правый сосед: p на том же уровне вложенности, который идёт сразу после div (если есть).

// При выборе элемента можно указать его место среди соседей.
// Список псевдоклассов для этого:
// :first-child – первый потомок своего родителя.
// :last-child – последний потомок своего родителя.
// :only-child – единственный потомок своего родителя, соседних элементов нет.
// :nth-child(a) – потомок номер a своего родителя, например :nth-child(2) – второй потомок. Нумерация начинается с 1.
// :nth-child(an+b) – расширение предыдущего селектора через указание номера потомка формулой, где a,b – константы, а под n подразумевается любое целое число.
// Этот псевдокласс будет фильтровать все элементы, которые попадают под формулу при каком-либо n. Например: -:nth-child(2n) даст элементы номер 2, 4, 6…, то есть чётные.
// :nth-child(2n+1) даст элементы номер 1, 3…, то есть нечётные.
// :nth-child(3n+2) даст элементы номер 2, 5, 8 и так далее.

// Есть аналогичные псевдоклассы, которые учитывают не всех соседей, а только с тем же тегом:
// :first-of-type
// :last-of-type
// :only-of-type
// :nth-of-type
// :nth-last-of-type
// Они имеют в точности тот же смысл, что и обычные :first-child, :last-child и так далее, но во время подсчёта игнорируют элементы с другими тегами, чем тот, к которому применяется фильтр.

// На атрибут целиком:
// [attr] – атрибут установлен,
// [attr="val"] – атрибут равен val.
// На начало атрибута:
// [attr^="val"] – атрибут начинается с val, например "value".
// [attr|="val"] – атрибут равен val или начинается с val-, например равен "val-1".
// На содержание:
// [attr*="val"] – атрибут содержит подстроку val, например равен "myvalue".
// [attr~="val"] – атрибут содержит val как одно из значений через пробел.
// Например: [attr~="delete"] верно для "edit delete" и неверно для "undelete" или "no-delete".
// На конец атрибута:
// [attr$="val"] – атрибут заканчивается на val, например равен "myval".

// :not(селектор) – все, кроме подходящих под селектор.
// :focus – в фокусе.
// :hover – под мышью.
// :empty – без детей (даже без текстовых).
// :checked, :disabled, :enabled – состояния INPUT.
// :target – этот фильтр сработает для элемента, ID которого совпадает с анкором #... текущего URL.
// Например, если на странице есть элемент с id="intro", то правило :target { color: red } подсветит его в том случае, если текущий URL имеет вид http://...#intro.